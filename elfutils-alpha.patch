2006-04-16  Jakub Bogusz  <qboosh at pld-linux dot org>

	* src/elflint.c (valid_e_machine) Add EM_ALPHA to valid machines.
	  (check_hash): Support hash bucket size of 8 on alpha and s390x.
	  (check_sections): Support arch-specific section flags.
	* libelf/elf32_getshdr.c: Handle unaligned section header with same
          endianess properly.
	* backends/alpha_init.c: Add register_name hook.
	* backends/alpha_regs.c: New file.
	* backends/Makefile.am: Add alpha_regs.c.

--- elfutils-0.116/src/elflint.c.orig	2005-11-26 10:28:00.000000000 +0100
+++ elfutils-0.116/src/elflint.c	2005-11-26 14:01:18.000000000 +0100
@@ -331,7 +331,7 @@
     EM_68HC16, EM_68HC11, EM_68HC08, EM_68HC05, EM_SVX, EM_ST19, EM_VAX,
     EM_CRIS, EM_JAVELIN, EM_FIREPATH, EM_ZSP, EM_MMIX, EM_HUANY, EM_PRISM,
     EM_AVR, EM_FR30, EM_D10V, EM_D30V, EM_V850, EM_M32R, EM_MN10300,
-    EM_MN10200, EM_PJ, EM_OPENRISC, EM_ARC_A5, EM_XTENSA
+    EM_MN10200, EM_PJ, EM_OPENRISC, EM_ARC_A5, EM_XTENSA, EM_ALPHA
   };
 #define nvalid_e_machine \
   (sizeof (valid_e_machine) / sizeof (valid_e_machine[0]))
@@ -1664,6 +1664,16 @@
 section [%2d] '%s': hash table not for dynamic symbol table\n"),
 	   idx, section_name (ebl, idx));
 
+  bool bighash = 
+    (ehdr->e_machine == EM_ALPHA) ||
+      ((ehdr->e_machine == EM_S390) && (ehdr->e_ident[EI_CLASS] == ELFCLASS64));
+
+  if (bighash) {
+    if (shdr->sh_entsize != 8) /* alpha and s390x use non-standard hash bucket size of 8 */
+      ERROR (gettext ("\
+section [%2d] '%s': entry size is not 8\n"),
+	     idx, section_name (ebl, idx));
+  } else
   if (shdr->sh_entsize != sizeof (Elf32_Word))
     ERROR (gettext ("\
 section [%2d] '%s': entry size does not match Elf32_Word\n"),
@@ -1681,8 +1691,15 @@
       return;
     }
 
-  Elf32_Word nbucket = ((Elf32_Word *) data->d_buf)[0];
-  Elf32_Word nchain = ((Elf32_Word *) data->d_buf)[1];
+  uint64_t nbucket, nchain;
+
+  if (bighash) {
+    nbucket = ((Elf64_Xword *) data->d_buf)[0];
+    nchain = ((Elf64_Xword *) data->d_buf)[1];
+  } else {
+    nbucket = ((Elf32_Word *) data->d_buf)[0];
+    nchain = ((Elf32_Word *) data->d_buf)[1];
+  }
 
   if (shdr->sh_size < (2 + nbucket + nchain) * shdr->sh_entsize)
     ERROR (gettext ("\
@@ -1694,29 +1711,41 @@
     {
       size_t symsize = symshdr->sh_size / symshdr->sh_entsize;
       size_t cnt;
-      Elf32_Word *buf, *end;
+      void *buf, *end;
+      uint64_t val;
 
       if (nchain < symshdr->sh_size / symshdr->sh_entsize)
 	ERROR (gettext ("section [%2d] '%s': chain array not large enough\n"),
 	       idx, section_name (ebl, idx));
 
+      if (bighash) {
+        buf = ((Elf64_Xword *) data->d_buf) + 2;
+        end = (Elf64_Xword *) ((char *) data->d_buf + shdr->sh_size);
+      } else {
       buf = ((Elf32_Word *) data->d_buf) + 2;
       end = (Elf32_Word *) ((char *) data->d_buf + shdr->sh_size);
-      for (cnt = 2; cnt < 2 + nbucket; ++cnt)
+      }
+      for (cnt = 2; cnt < 2 + nbucket; ++cnt) {
 	if (buf >= end)
 	  return;
-	else if (*buf++ >= symsize)
+	val = bighash ? *(Elf64_Xword *)buf : *(Elf32_Word *)buf;
+	if (val >= symsize)
 	  ERROR (gettext ("\
 section [%2d] '%s': hash bucket reference %zu out of bounds\n"),
 		 idx, section_name (ebl, idx), cnt - 2);
+	buf += bighash ? 8 : sizeof(Elf32_Word);
+      }
 
-      for (; cnt < 2 + nbucket + nchain; ++cnt)
+      for (; cnt < 2 + nbucket + nchain; ++cnt) {
 	if (buf >= end)
 	  return;
-	else if (*buf++ >= symsize)
+	val = bighash ? *(Elf64_Xword *)buf : *(Elf32_Word *)buf;
+	if (val >= symsize)
 	  ERROR (gettext ("\
 section [%2d] '%s': hash chain reference %zu out of bounds\n"),
 		 idx, section_name (ebl, idx), cnt - 2 - nbucket);
+	  buf += bighash ? 8 : sizeof(Elf32_Word);
+      }
     }
 }
 
@@ -2744,9 +2773,30 @@
 	       cnt, section_name (ebl, cnt),
 	       (int) shdr->sh_type);
 
-#define ALL_SH_FLAGS (SHF_WRITE | SHF_ALLOC | SHF_EXECINSTR | SHF_MERGE \
+#define GALL_SH_FLAGS (SHF_WRITE | SHF_ALLOC | SHF_EXECINSTR | SHF_MERGE \
 		      | SHF_STRINGS | SHF_INFO_LINK | SHF_LINK_ORDER \
 		      | SHF_OS_NONCONFORMING | SHF_GROUP | SHF_TLS)
+      uint64_t ALL_SH_FLAGS = GALL_SH_FLAGS; /* generic */
+      switch (ehdr->e_machine) {
+	case EM_MIPS:
+	  ALL_SH_FLAGS |= SHF_MIPS_GPREL | SHF_MIPS_MERGE | SHF_MIPS_ADDR |
+	    SHF_MIPS_STRINGS | SHF_MIPS_NOSTRIP | SHF_MIPS_LOCAL |
+	    SHF_MIPS_NAMES | SHF_MIPS_NODUPE;
+	  break;
+	case EM_PARISC:
+	  ALL_SH_FLAGS |= SHF_PARISC_SHORT | SHF_PARISC_HUGE | SHF_PARISC_SBP;
+	  break;
+	case EM_ALPHA:
+	  ALL_SH_FLAGS |= SHF_ALPHA_GPREL;
+	  break;
+	case EM_ARM:
+	  ALL_SH_FLAGS |= SHF_ARM_ENTRYSECT | SHF_ARM_COMDEF;
+	  break;
+	case EM_IA_64:
+	  ALL_SH_FLAGS |= SHF_IA_64_SHORT | SHF_IA_64_NORECOV;
+	  break;
+      }
+
       if (shdr->sh_flags & ~ALL_SH_FLAGS)
 	ERROR (gettext ("section [%2zu] '%s' contains unknown flag(s)"
 			" %#" PRIx64 "\n"),
--- elfutils-0.119/libelf/elf32_getshdr.c.orig	2006-02-05 18:17:07.948304250 +0100
+++ elfutils-0.119/libelf/elf32_getshdr.c	2006-02-05 18:26:52.836857500 +0100
@@ -107,7 +107,10 @@
 	    }
 
 	  /* Now copy the data and at the same time convert the byte
-	     order.  */
+	     order, if needed.  */
+	  if (ehdr->e_ident[EI_DATA] == MY_ELFDATA)
+	    memcpy (shdr, ((char*) elf->map_address + elf->start_offset + ehdr->e_shoff), size);
+	  else {
 	  if (ALLOW_UNALIGNED
 	      || (((uintptr_t) elf->map_address + elf->start_offset
 		   + ehdr->e_shoff)
@@ -136,6 +139,7 @@
 	      CONVERT_TO (shdr[cnt].sh_addralign, notcvt[cnt].sh_addralign);
 	      CONVERT_TO (shdr[cnt].sh_entsize, notcvt[cnt].sh_entsize);
 	    }
+	  }
 	}
       else if (likely (elf->fildes != -1))
 	{
--- elfutils-0.120/backends/alpha_init.c.orig	2006-04-05 00:17:36.000000000 +0200
+++ elfutils-0.120/backends/alpha_init.c	2006-04-16 13:11:08.819218500 +0200
@@ -54,6 +54,7 @@
   HOOK (eh, dynamic_tag_check);
   HOOK (eh, reloc_simple_type);
   HOOK (eh, return_value_location);
+  HOOK (eh, register_name);
 
   return MODVERSION;
 }
--- elfutils-0.120/backends/alpha_regs.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ elfutils-0.120/backends/alpha_regs.c	2006-04-16 13:10:15.947914250 +0200
@@ -0,0 +1,81 @@
+/* Register names and numbers for ALPHA DWARF.
+   Based on i386_regs.c, Copyright (C) 2005 Red Hat, Inc.
+   This file is part of Red Hat elfutils.
+
+   Red Hat elfutils is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by the
+   Free Software Foundation; version 2 of the License.
+
+   Red Hat elfutils is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with Red Hat elfutils; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301 USA.
+
+   Red Hat elfutils is an included package of the Open Invention Network.
+   An included package of the Open Invention Network is a package for which
+   Open Invention Network licensees cross-license their patents.  No patent
+   license is granted, either expressly or impliedly, by designation as an
+   included package.  Should you wish to participate in the Open Invention
+   Network licensing program, please visit www.openinventionnetwork.com
+   <http://www.openinventionnetwork.com>.  */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <string.h>
+
+#define BACKEND alpha_
+#include "libebl_CPU.h"
+
+ssize_t
+alpha_register_name (Ebl *ebl __attribute__ ((unused)),
+		    int regno, char *name, size_t namelen,
+		    const char **prefix, const char **setname)
+{
+  if (name == NULL)
+    return 33;
+
+  if (regno < 0 || regno > 64 || namelen < 5)
+    return -1;
+
+  *prefix = "%";
+  if (regno < 32)
+    *setname = "integer";
+  else if (regno < 64)
+    *setname = "fp";
+  else
+    *setname = "pc";
+
+  switch (regno)
+    {
+      static const char *alpharegs[] =
+	{
+	  "v0", "t0", "t1", "t2", "t3", "t4", "t5", "t6",
+	  "t7", "s0", "s1", "s2", "s3", "s4", "s5", "s6",
+	  "a0", "a1", "a2", "a3", "a4", "a5", "t8", "t9",
+	  "t10","t11","ra", "t12","at", "gp", "sp", "zero",
+	  "fv0","fv1","fs0","fs1","fs2","fs3","fs4","fs5",
+	  "fs6","fs7","ft0","ft1","ft2","ft3","ft4","ft5",
+	  "fa0","fa1","fa2","fa3","fa4","fa5","ft6","ft7",
+	  "ft8","ft9","ft10","ft11","ft12","ft13","ft14","fzero",
+	  "pc"
+	};
+
+    case 0 ... 64:
+      strcpy(name, alpharegs[regno]);
+      namelen = strlen(name);
+      break;
+
+    default:
+      name[0] = '\0';
+      *setname = NULL;
+      return 0;
+    }
+
+  return namelen;
+}
--- elfutils-0.120/backends/Makefile.am.orig	2006-04-16 13:15:56.425192000 +0200
+++ elfutils-0.120/backends/Makefile.am	2006-04-16 13:28:26.928096250 +0200
@@ -90,7 +90,7 @@
 libebl_ia64_pic_a_SOURCES = $(ia64_SRCS)
 am_libebl_ia64_pic_a_OBJECTS = $(ia64_SRCS:.c=.os)
 
-alpha_SRCS = alpha_init.c alpha_symbol.c alpha_retval.c
+alpha_SRCS = alpha_init.c alpha_symbol.c alpha_retval.c alpha_regs.c
 libebl_alpha_pic_a_SOURCES = $(alpha_SRCS)
 am_libebl_alpha_pic_a_OBJECTS = $(alpha_SRCS:.c=.os)
 
