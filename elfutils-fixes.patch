--- elfutils-0.137/libdwfl/ChangeLog
+++ elfutils-0.137/libdwfl/ChangeLog
@@ -1,3 +1,12 @@
+2008-08-28  Roland McGrath  <roland@redhat.com>
+
+	* segment.c (reify_segments): Fix last change.
+
+2008-08-27  Roland McGrath  <roland@redhat.com>
+
+	* linux-proc-maps.c (read_proc_memory): Return 0 for EINVAL or EPERM
+	failure from pread64.
+
 2008-08-26  Roland McGrath  <roland@redhat.com>
 
 	* segment.c (reify_segments): Insert a trailing segment for a module
--- elfutils-0.137/libdwfl/linux-proc-maps.c
+++ elfutils-0.137/libdwfl/linux-proc-maps.c
@@ -267,6 +267,9 @@ read_proc_memory (void *arg, void *data,
 {
   const int fd = *(const int *) arg;
   ssize_t nread = pread64 (fd, data, maxread, (off64_t) address);
+  /* Some kernels don't actually let us do this read, ignore those errors.  */
+  if (nread < 0 && (errno == EINVAL || errno == EPERM))
+    return 0;
   if (nread > 0 && (size_t) nread < minread)
     nread = 0;
   return nread;
--- elfutils-0.137/libdwfl/segment.c
+++ elfutils-0.137/libdwfl/segment.c
@@ -175,9 +175,17 @@ reify_segments (Dwfl *dwfl)
 	      return true;
 	    ++idx;
 	  }
+	else if (dwfl->lookup_addr[idx] < start)
+	  {
+	    /* The module starts past the end of this segment.
+	       Add a new one.  */
+	    if (unlikely (insert (dwfl, idx + 1, start, end, -1)))
+	      return true;
+	    ++idx;
+	  }
 
-	if (((size_t) idx + 1 == dwfl->lookup_elts
-	     || end < dwfl->lookup_addr[idx + 1])
+	if ((size_t) idx + 1 < dwfl->lookup_elts
+	    && end < dwfl->lookup_addr[idx + 1]
 	    /* The module ends in the middle of this segment.  Split it.  */
 	    && unlikely (insert (dwfl, idx + 1,
 				 end, dwfl->lookup_addr[idx + 1], -1)))
--- elfutils-0.137/libelf/ChangeLog
+++ elfutils-0.137/libelf/ChangeLog
@@ -1,3 +1,9 @@
+2008-08-27  Roland McGrath  <roland@redhat.com>
+
+	* elf_begin.c (get_shnum): Avoid misaligned reads for matching endian.
+
+	* libelfP.h [!ALLOW_UNALIGNED] (__libelf_type_align): Fix CLASS index.
+
 2008-08-25  Roland McGrath  <roland@redhat.com>
 
 	* Makefile.am (libelf_so_LDLIBS): New variable.
--- elfutils-0.137/libelf/elf_begin.c
+++ elfutils-0.137/libelf/elf_begin.c
@@ -110,8 +110,14 @@ get_shnum (void *map_address, unsigned c
   } ehdr_mem;
   bool is32 = e_ident[EI_CLASS] == ELFCLASS32;
 
+  // e_shnum shoff
+
   /* Make the ELF header available.  */
-  if (e_ident[EI_DATA] == MY_ELFDATA)
+  if (e_ident[EI_DATA] == MY_ELFDATA
+      && (ALLOW_UNALIGNED
+	  || (((size_t) e_ident
+	       & ((is32 ? __alignof__ (Elf32_Ehdr) : __alignof__ (Elf64_Ehdr))
+		  - 1)) == 0)))
     ehdr.p = e_ident;
   else
     {
@@ -130,8 +136,11 @@ get_shnum (void *map_address, unsigned c
 	  else
 	    memcpy (&ehdr_mem, e_ident, sizeof (Elf32_Ehdr));
 
-	  CONVERT (ehdr_mem.e32.e_shnum);
-	  CONVERT (ehdr_mem.e32.e_shoff);
+	  if (e_ident[EI_DATA] != MY_ELFDATA)
+	    {
+	      CONVERT (ehdr_mem.e32.e_shnum);
+	      CONVERT (ehdr_mem.e32.e_shoff);
+	    }
 	}
       else
 	{
@@ -143,8 +152,11 @@ get_shnum (void *map_address, unsigned c
 	  else
 	    memcpy (&ehdr_mem, e_ident, sizeof (Elf64_Ehdr));
 
-	  CONVERT (ehdr_mem.e64.e_shnum);
-	  CONVERT (ehdr_mem.e64.e_shoff);
+	  if (e_ident[EI_DATA] != MY_ELFDATA)
+	    {
+	      CONVERT (ehdr_mem.e64.e_shnum);
+	      CONVERT (ehdr_mem.e64.e_shoff);
+	    }
 	}
     }
 
--- elfutils-0.137/libelf/libelfP.h
+++ elfutils-0.137/libelf/libelfP.h
@@ -460,7 +460,7 @@ extern const uint_fast8_t __libelf_type_
    version, binary class, and type. */
 extern const uint_fast8_t __libelf_type_aligns[EV_NUM - 1][ELFCLASSNUM - 1][ELF_T_NUM] attribute_hidden;
 # define __libelf_type_align(class, type)	\
-    (__libelf_type_aligns[LIBELF_EV_IDX][class][type] ?: 1)
+    (__libelf_type_aligns[LIBELF_EV_IDX][class - 1][type] ?: 1)
 #else
 # define __libelf_type_align(class, type)	1
 #endif
