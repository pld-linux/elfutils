diff -uNr elfutils-0.94.orig/libdw/dwarf_getaranges.c elfutils-0.94/libdw/dwarf_getaranges.c
--- elfutils-0.94.orig/libdw/dwarf_getaranges.c	2004-01-12 21:08:03.000000000 +0100
+++ elfutils-0.94/libdw/dwarf_getaranges.c	2004-04-02 19:03:13.297222616 +0200
@@ -50,13 +50,13 @@
   struct arangelist *arangelist = NULL;
   unsigned int narangelist = 0;
 
-  const char *readp
-    = (const char *) dbg->sectiondata[IDX_debug_aranges]->d_buf;
-  const char *readendp = readp + dbg->sectiondata[IDX_debug_aranges]->d_size;
+  unsigned char *readp
+    = (unsigned char *) dbg->sectiondata[IDX_debug_aranges]->d_buf;
+  const unsigned char *readendp = readp + dbg->sectiondata[IDX_debug_aranges]->d_size;
 
   while (readp < readendp)
     {
-      const char *hdrstart = readp;
+      const unsigned char *hdrstart = readp;
 
       /* Each entry starts with a header:
 
@@ -75,15 +75,15 @@
 
 	 5. A 1-byte unsigned integer containing the size in bytes of
 	 a segment descriptor on the target system.  */
-      Dwarf_Word length = read_4ubyte_unaligned_inc (dbg, readp);
+      Dwarf_Word length = read_4ubyte_unaligned_inc (dbg, &readp);
       unsigned int length_bytes = 4;
       if (length == 0xffffffff)
 	{
-	  length = read_8ubyte_unaligned_inc (dbg, readp);
+	  length = read_8ubyte_unaligned_inc (dbg, &readp);
 	  length_bytes = 8;
 	}
 
-      unsigned int version = read_2ubyte_unaligned_inc (dbg, readp);
+      unsigned int version = read_2ubyte_unaligned_inc (dbg, &readp);
       if (version != 2)
 	{
 	invalid:
@@ -93,9 +93,9 @@
 
       Dwarf_Word offset;
       if (length_bytes == 4)
-	offset = read_4ubyte_unaligned_inc (dbg, readp);
+	offset = read_4ubyte_unaligned_inc (dbg, &readp);
       else
-	offset = read_8ubyte_unaligned_inc (dbg, readp);
+	offset = read_8ubyte_unaligned_inc (dbg, &readp);
 
       unsigned int address_size = *readp++;
       if (address_size != 4 && address_size != 8)
@@ -118,13 +118,13 @@
 
 	  if (address_size == 4)
 	    {
-	      range_address = read_4ubyte_unaligned_inc (dbg, readp);
-	      range_length = read_4ubyte_unaligned_inc (dbg, readp);
+	      range_address = read_4ubyte_unaligned_inc (dbg, &readp);
+	      range_length = read_4ubyte_unaligned_inc (dbg, &readp);
 	    }
 	  else
 	    {
-	      range_address = read_8ubyte_unaligned_inc (dbg, readp);
-	      range_length = read_8ubyte_unaligned_inc (dbg, readp);
+	      range_address = read_8ubyte_unaligned_inc (dbg, &readp);
+	      range_length = read_8ubyte_unaligned_inc (dbg, &readp);
 	    }
 
 	  /* Two zero values mark the end.  */
diff -uNr elfutils-0.94.orig/libdw/dwarf_getloclist.c elfutils-0.94/libdw/dwarf_getloclist.c
--- elfutils-0.94.orig/libdw/dwarf_getloclist.c	2004-01-09 09:39:54.000000000 +0100
+++ elfutils-0.94/libdw/dwarf_getloclist.c	2004-04-02 19:03:32.961233232 +0200
@@ -117,14 +117,14 @@
 		  return -1;
 		}
 
-	      newloc->number = read_4ubyte_unaligned_inc (dbg, data);
+	      newloc->number = read_4ubyte_unaligned_inc (dbg, &data);
 	    }
 	  else
 	    {
 	      if (unlikely (data + 8 > end_data))
 		goto invalid;
 
-	      newloc->number = read_8ubyte_unaligned_inc (dbg, data);
+	      newloc->number = read_8ubyte_unaligned_inc (dbg, &data);
 	    }
 	  break;
 
@@ -177,14 +177,14 @@
 	  if (unlikely (data >= end_data))
 	    goto invalid;
 
-	  newloc->number = *((int8_t *) data)++;
+	  newloc->number = *(int8_t *)data++;
 	  break;
 
 	case DW_OP_const2u:
 	  if (unlikely (data + 2 > end_data))
 	    goto invalid;
 
-	  newloc->number = read_2ubyte_unaligned_inc (dbg, data);
+	  newloc->number = read_2ubyte_unaligned_inc (dbg, &data);
 	  break;
 
 	case DW_OP_const2s:
@@ -194,14 +194,14 @@
 	  if (unlikely (data + 2 > end_data))
 	    goto invalid;
 
-	  newloc->number = read_2sbyte_unaligned_inc (dbg, data);
+	  newloc->number = read_2sbyte_unaligned_inc (dbg, &data);
 	  break;
 
 	case DW_OP_const4u:
 	  if (unlikely (data + 4 > end_data))
 	    goto invalid;
 
-	  newloc->number = read_4ubyte_unaligned_inc (dbg, data);
+	  newloc->number = read_4ubyte_unaligned_inc (dbg, &data);
 	  break;
 
 	case DW_OP_const4s:
@@ -209,21 +209,21 @@
 	  if (unlikely (data + 4 > end_data))
 	    goto invalid;
 
-	  newloc->number = read_4sbyte_unaligned_inc (dbg, data);
+	  newloc->number = read_4sbyte_unaligned_inc (dbg, &data);
 	  break;
 
 	case DW_OP_const8u:
 	  if (unlikely (data + 8 > end_data))
 	    goto invalid;
 
-	  newloc->number = read_8ubyte_unaligned_inc (dbg, data);
+	  newloc->number = read_8ubyte_unaligned_inc (dbg, &data);
 	  break;
 
 	case DW_OP_const8s:
 	  if (unlikely (data + 8 > end_data))
 	    goto invalid;
 
-	  newloc->number = read_8sbyte_unaligned_inc (dbg, data);
+	  newloc->number = read_8sbyte_unaligned_inc (dbg, &data);
 	  break;
 
 	case DW_OP_constu:
diff -uNr elfutils-0.94.orig/libdw/dwarf_getpubnames.c elfutils-0.94/libdw/dwarf_getpubnames.c
--- elfutils-0.94.orig/libdw/dwarf_getpubnames.c	2004-01-16 09:34:11.000000000 +0100
+++ elfutils-0.94/libdw/dwarf_getpubnames.c	2004-04-02 19:03:13.299222312 +0200
@@ -56,10 +56,10 @@
 
       /* Read the set header.  */
       int len_bytes = 4;
-      Dwarf_Off len = read_4ubyte_unaligned_inc (dbg, readp);
+      Dwarf_Off len = read_4ubyte_unaligned_inc (dbg, &readp);
       if (len == 0xffffffff)
 	{
-	  len = read_8ubyte_unaligned_inc (dbg, readp);
+	  len = read_8ubyte_unaligned_inc (dbg, &readp);
 	  len_bytes = 8;
 	}
 
@@ -169,9 +169,9 @@
 	{
 	  /* READP points to the next offset/name pair.  */
 	  if (dbg->pubnames_sets[cnt].address_len == 4)
-	    gl.die_offset = read_4ubyte_unaligned_inc (dbg, readp);
+	    gl.die_offset = read_4ubyte_unaligned_inc (dbg, &readp);
 	  else
-	    gl.die_offset = read_8ubyte_unaligned_inc (dbg, readp);
+	    gl.die_offset = read_8ubyte_unaligned_inc (dbg, &readp);
 
 	  /* If the offset is zero we reached the end of the set.  */
 	  if (gl.die_offset == 0)
diff -uNr elfutils-0.94.orig/libdw/dwarf_getsrclines.c elfutils-0.94/libdw/dwarf_getsrclines.c
--- elfutils-0.94.orig/libdw/dwarf_getsrclines.c	2004-01-12 01:30:17.000000000 +0100
+++ elfutils-0.94/libdw/dwarf_getsrclines.c	2004-04-02 19:03:31.124512456 +0200
@@ -109,13 +109,13 @@
 	  __libdw_seterrno (DWARF_E_INVALID_DEBUG_LINE);
 	  goto out;
 	}
-      Dwarf_Word unit_length = read_4ubyte_unaligned_inc (dbg, linep);
+      Dwarf_Word unit_length = read_4ubyte_unaligned_inc (dbg, &linep);
       unsigned int length = 4;
       if (unlikely (unit_length == 0xffffffff))
 	{
 	  if (linep + 8 > lineendp)
 	    goto invalid_data;
-	  unit_length = read_8ubyte_unaligned_inc (dbg, linep);
+	  unit_length = read_8ubyte_unaligned_inc (dbg, &linep);
 	  length = 8;
 	}
 
@@ -126,7 +126,7 @@
       lineendp = linep + unit_length;
 
       /* The next element of the header is the version identifier.  */
-      uint_fast16_t version = read_2ubyte_unaligned_inc (dbg, linep);
+      uint_fast16_t version = read_2ubyte_unaligned_inc (dbg, &linep);
       if (unlikely (version != DWARF_VERSION))
 	{
 	  __libdw_seterrno (DWARF_E_VERSION);
@@ -136,9 +136,9 @@
       /* Next comes the header length.  */
       Dwarf_Word header_length;
       if (length == 4)
-	header_length = read_4ubyte_unaligned_inc (dbg, linep);
+	header_length = read_4ubyte_unaligned_inc (dbg, &linep);
       else
-	header_length = read_8ubyte_unaligned_inc (dbg, linep);
+	header_length = read_8ubyte_unaligned_inc (dbg, &linep);
       unsigned char *header_start = linep;
 
       /* Next the minimum instruction length.  */
@@ -149,7 +149,7 @@
       uint_fast8_t default_is_stmt = *linep++;
 
       /* Now the line base.  */
-      int_fast8_t line_base = *((int_fast8_t *) linep)++;
+      int_fast8_t line_base = *(int_fast8_t *)linep++;
 
       /* And the line range.  */
       uint_fast8_t line_range = *linep++;
@@ -376,9 +376,9 @@
 
 		case DW_LNE_set_address:
 		  if (cu->address_size == 4)
-		    address = read_4ubyte_unaligned_inc (dbg, linep);
+		    address = read_4ubyte_unaligned_inc (dbg, &linep);
 		  else
-		    address = read_8ubyte_unaligned_inc (dbg, linep);
+		    address = read_8ubyte_unaligned_inc (dbg, &linep);
 		  break;
 
 		case DW_LNE_define_file:
diff -uNr elfutils-0.94.orig/libdw/dwarf_nextcu.c elfutils-0.94/libdw/dwarf_nextcu.c
--- elfutils-0.94.orig/libdw/dwarf_nextcu.c	2004-01-10 04:43:17.000000000 +0100
+++ elfutils-0.94/libdw/dwarf_nextcu.c	2004-04-02 19:03:13.305221400 +0200
@@ -47,7 +47,7 @@
 
   /* This points into the .debug_info section to the beginning of the
      CU entry.  */
-  char *bytes = (char *) dwarf->sectiondata[IDX_debug_info]->d_buf + off;
+  unsigned char *bytes = (char *) dwarf->sectiondata[IDX_debug_info]->d_buf + off;
 
   /* The format of the CU header is described in dwarf2p1 7.5.1:
 
@@ -74,7 +74,7 @@
 	 an address on the target architecture. If the system uses
 	 segmented addressing, this value represents the size of the
 	 offset portion of an address.  */
-  uint64_t length = read_4ubyte_unaligned_inc (dwarf, bytes);
+  uint64_t length = read_4ubyte_unaligned_inc (dwarf, &bytes);
   size_t offset_size = 4;
   if (length == 0xffffffffu)
     offset_size = 8;
@@ -93,19 +93,19 @@
 
   if (length == 0xffffffffu)
     /* This is a 64-bit DWARF format.  */
-    length = read_8ubyte_unaligned_inc (dwarf, bytes);
+    length = read_8ubyte_unaligned_inc (dwarf, &bytes);
 
   /* Read the version stamp.  Always a 16-bit value.
      XXX Do we need the value?  */
-  read_2ubyte_unaligned_inc (dwarf, bytes);
+  read_2ubyte_unaligned_inc (dwarf, &bytes);
 
   /* Get offset in .debug_abbrev.  Note that the size of the entry
      depends on whether this is a 32-bit or 64-bit DWARF definition.  */
   uint64_t abbrev_offset;
   if (offset_size == 4)
-    abbrev_offset = read_4ubyte_unaligned_inc (dwarf, bytes);
+    abbrev_offset = read_4ubyte_unaligned_inc (dwarf, &bytes);
   else
-    abbrev_offset = read_8ubyte_unaligned_inc (dwarf, bytes);
+    abbrev_offset = read_8ubyte_unaligned_inc (dwarf, &bytes);
   if (abbrev_offsetp != NULL)
     *abbrev_offsetp = abbrev_offset;
 
@@ -121,7 +121,7 @@
   /* Store the header length.  */
   if (header_sizep != NULL)
     *header_sizep = (bytes
-		     - ((char *) dwarf->sectiondata[IDX_debug_info]->d_buf
+		     - ((unsigned char *)dwarf->sectiondata[IDX_debug_info]->d_buf
 			+ off));
 
   /* See above for an explanation of the trick in this formula.  */
diff -uNr elfutils-0.94.orig/libdw/memory-access.h elfutils-0.94/libdw/memory-access.h
--- elfutils-0.94.orig/libdw/memory-access.h	2004-01-16 18:43:30.000000000 +0100
+++ elfutils-0.94/libdw/memory-access.h	2004-04-02 19:03:22.820774816 +0200
@@ -23,19 +23,19 @@
 /* Number decoding macros.  See 7.6 Variable Length Data.  */
 #define get_uleb128(var, addr) \
   do {									      \
-    unsigned char __b = *((const unsigned char *) addr)++;		      \
+    unsigned char __b = *(const unsigned char *)addr++;			      \
     var = __b & 0x7f;							      \
     if (__b & 0x80)							      \
       {									      \
-	__b = *((const unsigned char *) addr)++;			      \
+	__b = *(const unsigned char *)addr++;				      \
 	var |= (__b & 0x7f) << 7;					      \
 	if (__b & 0x80)							      \
 	  {								      \
-	    __b = *((const unsigned char *) addr)++;			      \
+	    __b = *(const unsigned char *)addr++;			      \
 	    var |= (__b & 0x7f) << 14;					      \
 	    if (__b & 0x80)						      \
 	      {								      \
-		__b = *((const unsigned char *) addr)++;		      \
+		__b = *(const unsigned char *)addr++;			      \
 		var |= (__b & 0x7f) << 21;				      \
 		if (__b & 0x80)						      \
 		  /* Other implementation set VALUE to UINT_MAX in this	      \
@@ -49,7 +49,7 @@
 /* The signed case is a big more complicated.  */
 #define get_sleb128(var, addr) \
   do {									      \
-    unsigned char __b = *((const unsigned char *) addr)++;		      \
+    unsigned char __b = *(const unsigned char *)addr++;			      \
     int32_t __res = __b & 0x7f;						      \
     if ((__b & 0x80) == 0)						      \
       {									      \
@@ -58,7 +58,7 @@
       }									      \
     else								      \
       {									      \
-	__b = *((const unsigned char *) addr)++;			      \
+	__b = *(const unsigned char *)addr++;				      \
 	__res |= (__b & 0x7f) << 7;					      \
 	if ((__b & 0x80) == 0)						      \
 	  {								      \
@@ -67,7 +67,7 @@
 	  }								      \
 	else								      \
 	  {								      \
-	    __b = *((const unsigned char *) addr)++;			      \
+	    __b = *(const unsigned char *)addr++;			      \
 	    __res |= (__b & 0x7f) << 14;				      \
 	    if ((__b & 0x80) == 0)					      \
 	      {								      \
@@ -76,7 +76,7 @@
 	      }								      \
 	    else							      \
 	      {								      \
-		__b = *((const unsigned char *) addr)++;		      \
+		__b = *(const unsigned char *)addr++;			      \
 		__res |= (__b & 0x7f) << 21;				      \
 		if ((__b & 0x80) == 0)					      \
 		  {							      \
@@ -200,31 +200,43 @@
 #endif	/* allow unaligned */
 
 
-#define read_2ubyte_unaligned_inc(Dbg, Addr) \
-  ({ uint16_t t_ = read_2ubyte_unaligned (Dbg, Addr);			      \
-     ++((const uint16_t *) (Addr));					      \
-     t_; })
-#define read_2sbyte_unaligned_inc(Dbg, Addr) \
-  ({ int16_t t_ = read_2sbyte_unaligned (Dbg, Addr);			      \
-     ++((const int16_t *) (Addr));					      \
-     t_; })
-
-#define read_4ubyte_unaligned_inc(Dbg, Addr) \
-  ({ uint32_t t_ = read_4ubyte_unaligned (Dbg, Addr);			      \
-     ++((const uint32_t *) (Addr));					      \
-     t_; })
-#define read_4sbyte_unaligned_inc(Dbg, Addr) \
-  ({ int32_t t_ = read_4sbyte_unaligned (Dbg, Addr);			      \
-     ++((const int32_t *) (Addr));					      \
-     t_; })
-
-#define read_8ubyte_unaligned_inc(Dbg, Addr) \
-  ({ uint64_t t_ = read_8ubyte_unaligned (Dbg, Addr);			      \
-     ++((const uint64_t *) (Addr));					      \
-     t_; })
-#define read_8sbyte_unaligned_inc(Dbg, Addr) \
-  ({ int64_t t_ = read_8sbyte_unaligned (Dbg, Addr);			      \
-     ++((const int64_t *) (Addr));					      \
-     t_; })
+static inline uint16_t read_2ubyte_unaligned_inc(Dwarf *dbg, unsigned char **p)
+{
+    uint16_t tmp = read_2ubyte_unaligned(dbg, *p);
+    *p += 2;
+    return tmp;
+}
+static inline int16_t read_2sbyte_unaligned_inc(Dwarf *dbg, unsigned char **p)
+{
+    int16_t tmp = read_2sbyte_unaligned(dbg, *p);
+    *p += 2;
+    return tmp;
+}
+
+static inline uint32_t read_4ubyte_unaligned_inc(Dwarf *dbg, unsigned char **p)
+{
+    uint32_t tmp = read_4ubyte_unaligned(dbg, *p);
+    *p += 4;
+    return tmp;
+}
+static inline int32_t read_4sbyte_unaligned_inc(Dwarf *dbg, unsigned char **p)
+{
+    int32_t tmp = read_4sbyte_unaligned(dbg, *p);
+    *p += 4;
+    return tmp;
+}
+
+static inline uint64_t read_8ubyte_unaligned_inc(Dwarf *dbg, unsigned char **p)
+{
+    uint64_t tmp = read_8ubyte_unaligned(dbg, *p);
+    *p += 8;
+    return tmp;
+}
+static inline int64_t read_8sbyte_unaligned_inc(Dwarf *dbg, unsigned char **p)
+{
+    int64_t tmp = read_8sbyte_unaligned(dbg, *p);
+    *p += 8;
+    return tmp;
+}
 
 #endif	/* memory-access.h */
diff -uNr elfutils-0.94.orig/libelf/dl-hash.h elfutils-0.94/libelf/dl-hash.h
--- elfutils-0.94.orig/libelf/dl-hash.h	2003-12-25 19:31:59.000000000 +0100
+++ elfutils-0.94/libelf/dl-hash.h	2004-04-02 19:03:13.296222768 +0200
@@ -26,28 +26,28 @@
 __attribute__ ((__pure__))
 _dl_elf_hash (const char *name)
 {
-  unsigned int hash = (unsigned int) *((const unsigned char *) name)++;
+  unsigned int hash = (unsigned int) *(const unsigned char *)name++;
   if (*name != '\0')
     {
       hash = ((hash << 4)
-	      + (unsigned int) *((const unsigned char *) name)++);
+	      + (unsigned int) *(const unsigned char *)name++);
       if (*name != '\0')
 	{
 	  hash = ((hash << 4)
-		  + (unsigned int) *((const unsigned char *) name)++);
+		  + (unsigned int) *(const unsigned char *)name++);
 	  if (*name != '\0')
 	    {
 	      hash = ((hash << 4)
-		      + (unsigned int) *((const unsigned char *) name)++);
+		      + (unsigned int) *(const unsigned char *)name++);
 	      if (*name != '\0')
 		{
 		  hash = ((hash << 4)
-			  + (unsigned int) *((const unsigned char *) name)++);
+			  + (unsigned int) *(const unsigned char *)name++);
 		  while (*name != '\0')
 		    {
 		      unsigned int hi;
 		      hash = ((hash << 4)
-			      + (unsigned int) *((const unsigned char *) name)++);
+			      + (unsigned int) *(const unsigned char *)name++);
 		      hi = hash & 0xf0000000;
 
 		      /* The algorithm specified in the ELF ABI is as
diff -uNr elfutils-0.94.orig/libelf/gelf_xlate.c elfutils-0.94/libelf/gelf_xlate.c
--- elfutils-0.94.orig/libelf/gelf_xlate.c	2003-12-25 19:42:38.000000000 +0100
+++ elfutils-0.94/libelf/gelf_xlate.c	2004-04-02 19:03:28.501911152 +0200
@@ -73,9 +73,10 @@
     if (dest < ptr)							      \
       while (n-- > 0)							      \
 	{								      \
-          *((word##Bytes##_t *) dest)++ =				      \
+          *((word##Bytes##_t *)dest) =					      \
 	    LEN##Bytes##_SWAP ((word##Bytes##_t *) ptr);		      \
-	  ((word##Bytes##_t *) ptr)++;					      \
+	  dest += sizeof(word##Bytes##_t *);				      \
+	  ptr += sizeof(word##Bytes##_t *);				      \
 	}								      \
     else								      \
       {									      \
diff -uNr elfutils-0.94.orig/src/ldgeneric.c elfutils-0.94/src/ldgeneric.c
--- elfutils-0.94.orig/src/ldgeneric.c	2003-08-18 01:49:51.000000000 +0200
+++ elfutils-0.94/src/ldgeneric.c	2004-04-02 19:03:35.409860984 +0200
@@ -2449,9 +2449,8 @@
     ld_state.outfname = "a.out";
 
   size_t outfname_len = strlen (ld_state.outfname);
-  char *tempfname = (char *) ld_state.tempfname
-    = (char *) obstack_alloc (&ld_state.smem,
-			      outfname_len + sizeof (".XXXXXX"));
+  char *tempfname = ld_state.tempfname
+    = obstack_alloc (&ld_state.smem, outfname_len + sizeof (".XXXXXX"));
 
   int fd;
   int try = 0;
diff -uNr elfutils-0.94.orig/src/ld.h elfutils-0.94/src/ld.h
--- elfutils-0.94.orig/src/ld.h	2003-08-12 08:46:39.000000000 +0200
+++ elfutils-0.94/src/ld.h	2004-04-02 19:03:35.412860528 +0200
@@ -752,7 +752,7 @@
   /* Name of the output file.  */
   const char *outfname;
   /* Name of the temporary file we initially create.  */
-  const char *tempfname;
+  char *tempfname;
   /* File descriptor opened for the output file.  */
   int outfd;
   /* The ELF descriptor for the output file.  */
diff -uNr elfutils-0.94.orig/src/readelf.c elfutils-0.94/src/readelf.c
--- elfutils-0.94.orig/src/readelf.c	2004-01-16 10:29:37.000000000 +0100
+++ elfutils-0.94/src/readelf.c	2004-04-02 19:03:35.418859616 +0200
@@ -2974,7 +2974,7 @@
   Dwarf_Word offset = 0;
   while (len-- > 0)
     {
-      size_t op = *((unsigned char *) data)++;
+      size_t op = *(unsigned char *)data++;
 
       switch (op)
 	{
@@ -3004,7 +3004,7 @@
 	case DW_OP_const1u:
 	  printf ("           %*s [%4" PRIuMAX "] %s %" PRIu8 "\n",
 		  (int) (20 + level * 2), "", (uintmax_t) offset,
-		  known[op] ?: "???", *((uint8_t *) data)++);
+		  known[op] ?: "???", *(uint8_t *)data++);
 	  --len;
 	  offset += 2;
 	  break;
@@ -3039,7 +3039,7 @@
 	case DW_OP_const1s:
 	  printf ("           %*s [%4" PRIuMAX "] %s %" PRId8 "\n",
 		  (int) (20 + level * 2), "", (uintmax_t) offset,
-		  known[op] ?: "???", *((int8_t *) data)++);
+		  known[op] ?: "???", *(int8_t *)data++);
 	  --len;
 	  offset += 2;
 	  break;
@@ -3090,7 +3090,7 @@
 	case DW_OP_consts:;
 	  start = data;
 	  unsigned int sleb;
-	  get_sleb128 (sleb, ((unsigned char *) data));
+	  get_sleb128 (sleb, (unsigned char *)data);
 	  printf ("           %*s [%4" PRIuMAX "] %s %d\n",
 		  (int) (20 + level * 2), "", (uintmax_t) offset,
 		  known[op] ?: "???", sleb);
@@ -3100,8 +3100,8 @@
 
 	case DW_OP_bregx:
 	  start = data;
-	  get_uleb128 (uleb, ((unsigned char *) data));
-	  get_sleb128 (sleb, ((unsigned char *) data));
+	  get_uleb128 (uleb, (unsigned char *)data);
+	  get_sleb128 (sleb, (unsigned char *)data);
 	  printf ("           %*s [%4" PRIuMAX "] %s %u %d\n",
 		  (int) (20 + level * 2), "", (uintmax_t) offset,
 		  known[op] ?: "???", uleb, sleb);
